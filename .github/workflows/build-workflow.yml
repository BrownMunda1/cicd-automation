name: build-workflow
run-name: Build Workflow

on:
  push:

permissions:
    contents: read

jobs:
    build:
        name: "Python Build"
        runs-on: ubuntu-latest

        steps:
        -   id: checkout
            name: Checkout
            uses: actions/checkout@v5
            with:
                fetch-depth: 0

        -   id: setup-python
            name: Set up Python 3.12
            uses: actions/setup-python@v5
            with:
                python-version: "3.12.x"

        -   id: display-version
            name: Display Python version
            run: python -c "import sys; print(sys.version)"

        -   id: setup-uv
            uses: astral-sh/setup-uv@v6
            with:
                version: "latest"

        -   id: display-uv-version
            name: Display uv version
            run: uv --version

        -   id: uv-build
            name: UV virtual environment, build and install
            run: |
                echo "Running uv sync for installing all packages in virutal environment from pyproject.toml file"
                uv sync

                echo "Falling back to requirements.txt if not present in pyproject.toml"
                if [ -e requirements.txt ]; then
                    uv add -r requirements.txt
                fi

                echo "Running uv build for creating whl files"
                uv build

        -   id: get-last-successful-workflow-run
            name: Get last Successful Workflow Run
            uses: actions/github-script@v8
            with:
                script: |
                    const { owner, repo } = context.repo;
                    const runs = await github.rest.actions.listWorkflowRunsForRepo({
                        owner,
                        repo,
                        per_page: 100
                    })
                    
                    const workflowRuns = runs.data.workflow_runs;
                    workflowRuns.sort((a,b) => {
                        const timea = a.head_commit.timestamp;
                        const timeb = b.head_commit.timestamp;
                        return timeb-timea;
                    });
                    const lastSuccessfulWorkflow = workflowRuns.find(workflow => workflow.status === "completed" && workflow.conclusion === "success")
                    return lastSuccessfulWorkflow.head_sha

        -   id: get-changed-repos
            name: Get Changed Repositories
            run: |

                # # echo "Printing changed files names and status"
                # # python -m src.main --files-changed "$files_changed"
                # modified_files=$(git diff --name-only --diff-filter=M "${{ steps.get-last-successful-workflow-run.outputs.result }}" "${{ github.sha }}")

                # # echo "Printing modified files=$modified_files"

                
                # # python -m src.main --modified-files "$modified_files"
                # # python -m src.main --files-changed "$files_changed" --modified-files "$modified_files"

                # # temp=$(git diff --unified=0 --no-prefix "${{ steps.get-last-successful-workflow-run.outputs.result }}" "${{ github.sha }}")
                # # echo "Printing all changed files=$temp"


                # # Get the names of all the files changed. Filter out non-important ones manually. Then Provide each file's content to LLM individually, and let it analyse if it contributes in the build or not. If yes, then build it, if not then leave it as it is.


                # # echo "Github Difference from last commit = $temp"
                # # result=$(python -m src.main "$temp")
                # # echo "GIT DIFF: $result"
                # # declare -A modified_files_dict
                # # for FILE in $modified_files; do
                # #     file_diff=$(git diff --unified=0 --no-prefix "${{ steps.get-last-successful-workflow-run.outputs.result }}" "${{ github.sha }}" -- "$FILE") 

                # #     modified_files_dict["$FILE"]="$file_diff"
                # # done

                # modified_files_diff=""
                # for FILE in $modified_files; do
                #     file_diff=$(git diff --unified=0 --no-prefix "${{ steps.get-last-successful-workflow-run.outputs.result }}" "${{ github.sha }}" -- "$FILE")
                #     # append the diff (preserve newlines)
                #     modified_files_diff+=$'STARTTTTTTTT'"$file_diff"$'ENDDDDDDDDDDDDDDD'
                # done

                # echo "Printing modified files diff:"
                # # printf '%s' "$modified_files_diff" | sed -n '1,200p'

                # # pass the multiline string to Python (quotes preserve newlines)
                # python -m src.main --modified-files "$modified_files_diff"

                # # echo "Printing modified files dict"
                # # python -m src.main --modified-files "$modified_files_dict"



                # # repos_changed=()
                # # for FILE in $temp; do
                # #     if [[ "$FILE" == src/* ]]; then
                # #         IFS='/'; arrIN=($FILE); unset IFS;
                # #         repos_changed+=( ${arrIN[1]} )
                # #     fi
                # # done

                # # echo "REPOS_CHANGED=$repos_changed" >> $GITHUB_OUTPUT


                files_changed=$(git diff --name-status "${{ steps.get-last-successful-workflow-run.outputs.result }}" "${{ github.sha }}")

                modified_base="${{ steps.get-last-successful-workflow-run.outputs.result }}"
                current="${{ github.sha }}"

                export BASE_SHA="$modified_base"
                export HEAD_SHA="$current"

                # Build a JSON file mapping filename -> diff (handles quoting/newlines safely)
                python - <<'PY'
                import os, json, subprocess, sys

                base = os.environ['BASE_SHA']
                head = os.environ['HEAD_SHA']
                workspace = os.environ.get('GITHUB_WORKSPACE', '.')

                # list modified files
                p = subprocess.run(['git','diff','--name-only','--diff-filter=M', base, head],
                                capture_output=True, text=True, check=True)
                files = [f for f in p.stdout.splitlines() if f.strip()]

                result = {}
                for f in files:
                    # get per-file diff
                    d = subprocess.run(['git','diff','--unified=0','--no-prefix', base, head, '--', f],
                                    capture_output=True, text=True, check=True)
                    result[f] = d.stdout

                out_path = os.path.join(workspace, 'modified_files.json')
                with open(out_path, 'w', encoding='utf-8') as fh:
                    json.dump(result, fh, ensure_ascii=False)

                print(out_path)
                PY

                # consume the JSON in your python module (or pass the path)
                source .venv/bin/activate
                monorepos_to_build=$(python -m src.main --files-changed "$files_changed" --modified-files-json "$GITHUB_WORKSPACE/modified_files.json")

                # echo "REPOS_TO_BUILD=$monorepos_to_build" >> $GITHUB_OUTPUT
                {
                  echo "REPOS_TO_BUILD<<EOF"
                  echo "$monorepos_to_build"
                  echo "EOF"
                } >> $GITHUB_OUTPUT


        -   id: build-individual-projects
            name: Build Projects
            run: |
                cd src
                for REPO in ${{ steps.get-changed-repos.outputs.REPOS_TO_BUILD }}; do
                    cd $REPO
                    uv sync
                    if [ -e requirements.txt ]; then
                        uv add -r requirements.txt
                    fi
                    uv build
                    # temp=$(python -m main I am Ankit)
                    # echo "Python Script Answer: $temp"
                    cd ..
                    echo "$REPO Built successfully"
                done
